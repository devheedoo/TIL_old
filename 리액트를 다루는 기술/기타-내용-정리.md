# 기타 내용 정리

## 3장: 컴포넌트

- 리액트를 사용하여 애플리케이션 인터페이스를 설계할 때 각 요소는 **컴포넌트**라는 구조체로 작성한다.
- 컴포넌트의 데이터는 2가지로 나뉘는데, 부모 컴포넌트가 설정해주는 **props**와 자체적으로 갖는 **state**이다.
- 물론 자식 컴포넌트에서 부모 컴포넌트의 메서드를 호출하면 props도 변경할 수 있다.

## 5장:  ref: DOM에 이름 달기

- **ref**는 HTML에서 id를 사용해 DOM에 이름을 다는 것처럼 리액트 프로젝트 내부에서DOM에 이름을 다는 방법이다.
- DOM에서 직접 접근 시에는 ref를 꼭 사용해야 하는지 먼저 검토해야 한다.
- 컴포넌트간 데이터 교류 시 ref를 사용하는 것은 잘못된 사용이다. 컴포넌트간 데이터 교류 시에는 반드시 부모-자식 흐름으로 교류해야 한다.
- 리덕스

## 6장: 컴포넌트 반복

- 웹 애플리케이션에서 반복되는 코드를 작성할 때가 있는데 리액트에서는 map을 활용하는 방법이 있다.
- 컴포넌트 배열을 렌더링할 때는 **key** 값 설정에 항상 주의해야 한다.
- 상태 안에서 배열을 변형할 때는 반드시 복사해서 변경한 후 setState 메서드로 적용한다.
- 복사해서 변경할 때 사용하는 함수: concat, slice, 전개 연산자, filter

## 12장: 리덕스 개념 이해

- **리덕스**는 상태 관리 로직을 컴포넌트 밖에서 처리할 수 있도록 도와주는 자바스크립트 라이브러리다.

상태 정보는 **스토어**라는 객체 내부에 저장한다. 상태 변화를 일으킬 때 **액션**이라는 것을 스토어에 전달한다. 액션을 전달하는 과정을 **디스패치**라고 한다. **리듀서**가 액션을 처리한다. 스토어 안에 있는 상태가 바뀌면 해당 정보를 **구독**하고 있는 컴포넌트에 바로 전달한다.

- 스토어: 애플리케이션의 상태 값 내장
- 액션: 상태 변화를 일으킬 때 차몾하는 객체
- 디스패치: 액션을 스토어에 전달하는 것
- 리듀서: 상태 변화시키는 로직이 있는 함수
- 구독: 스토어 값이 필요한 컴포넌트는 스토어를 **구독**한다고 한다.

## 17장: 코드 스플리팅

- 싱글 페이지 애플리케이션의 단점은 첫 페이지 로딩 속도가 지연될 수 있다는 것이다.
- 첫 화면에서 자바스크립트 번들 파일에 모든 애플리케이션 로직을 불러오기 때문이다.
- 코드 스플리팅은 이를 여러 개로 분할해서 필요한 시점에 불러올 수 있도록 해준다.
- 서드파티 라이브러리들을 vendor로 따로 분리할 수 있다.
- chunk를 생성해 페이지를 로딩할 때 필요한 파일만 불러오고, 비동기적으로 불러와 사용할 수 있다. import를 함수 내부에서 작성해야 한다.
- 비동기적 로딩 모듈 예제 코드: asyncComponenet.js
- 당연하지만 어느정도 규모가 커지기 전엔 효율성이 떨어진다.